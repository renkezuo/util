//7个班，14个老师，11个科目
//每天8课时，每位老师最多6课时--->每周40课时
//语数外：6课时/每周；政史地，理化生：3课时/周；体技：2课时/每周--->合计18+18+4=40
//每科目最少需要多少位老师？	语数外：	42课时/每周；	政史地，理化生：	21课时/周；	体技：	14课时/周
//语数外：	42课时/每周，9课时/日；每位老师最多6课时，需要2位老师，每天工作不少于4课时，不大于6
//政史地，理化生：21课时/周；5课时/日；每位老师最多6课时，需要1位老师，每天工作不少于4课时，不大于6
//体技：14课时/周；3课时/日；每位老师最多6课时，需要1位老师，每天工作不少于3课时



##实现方式
A、计算所有班级科目的可能分布，组合，组合完毕，即课表
班级科目[班级单科每天最多课时数]，总课时数
通过总课时/每天课时数-->计算至少需要的天数
if(count%day == 0){
	days = count/maxDay;
}else{
	days = count/day +1;
}
有了天数，产生组合
for(int i=days;i<6;i++){
	x + x + x + x + x = count
}

##老师总数，班级总数，课时总数
##课时多，则加老师，老师多，则可分配到其他

##所有的组合
for(int i1=1;i1<= maxDay ; i1++){
	if(i1 == count){
		//记录一次
	}
	for(int i2=1 ; i2<= maxDay ; i2++){
		if(i1+i2==count){
			//记录一次
		}
		for(int i3=1 ; i3<= maxDay ; i3++){
			if(i1+i2+i3==count){
				//记录一次
			}
			for(int i4=1 ; i4<= maxDay ; i4++){
				if(i1+i2+i3+i4==count){
					//记录一次
				}
				for(int i5=1 ; i5<= maxDay ; i5++){
					if(i1+i2+i3+i4+i5==count){
						//记录一次
					}
				}
			}
		}
	}
}
##如何组合？
##穷举
### 7个班，8个课时，11科目[x个组合*7]
### 先分配老师[教案平齐]
##遍历课时[]

###准备两种方式：
###1、每个班级一个集合，动态保存班级科目剩余数，对应的科目列表[优点：优先处理连堂信息，可以控制是否散列老师资源，教案平齐]
###先排上午，取课时多的先排课，如果课时多的老师当日没有课时了，则逐级向下，优先多节连排
###根据时间排序，周一上午[7个班依次]，周一下午[7个班依次]...
###上午优先排课时多的，下午优先排课时少的




###2、每天一个集合，动态保存老师剩余课时数，剩余越多的越优先[优点：极限使用教师资源，散列老师资源，速度最快]
###再排下午，取课时少的排课，如果课时少的老师当日没有课时了，则逐级向上，优先1节

















##时间不可控
B、每天随机获取课表，日终，判断[剩余老师科目总数<日课时上限*天数]，最后一天不需要排课